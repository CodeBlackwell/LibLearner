#!/usr/bin/env python3

import argparse
import os
import sys
from liblearner.extractor import process_directory, process_file, write_results_to_csv

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Extract functions from Python files and save them to CSV format."
    )
    parser.add_argument(
        "input_path",
        help="Path to Python file or directory to process"
    )
    parser.add_argument(
        "-o", "--output",
        help="Output directory for CSV files (default: ./output)",
        default="output"
    )
    parser.add_argument(
        "--ignore-dirs",
        nargs="*",
        help="Directories to ignore (default: venv .git ds_venv dw_env)",
        default=["venv", ".git", "ds_venv", "dw_env"]
    )
    parser.add_argument(
        "--globals-only",
        action="store_true",
        help="Only extract global functions"
    )
    return parser.parse_args()

def log_error(file_path, error_message):
    """Log errors to stderr."""
    print(f"Error processing {file_path}: {error_message}", file=sys.stderr)

def show_progress(processed_files, total_files, current_file):
    """Display progress information."""
    progress = (processed_files / total_files) * 100
    print(f"Progress: {progress:.2f}% - Processed {current_file}")

def main():
    args = parse_arguments()
    
    # Create output directory if it doesn't exist
    os.makedirs(args.output, exist_ok=True)
    
    # Process input path
    if os.path.isdir(args.input_path):
        folder_functions = process_directory(
            args.input_path,
            args.ignore_dirs,
            error_callback=log_error,
            progress_callback=show_progress,
            globals_only=args.globals_only
        )
        
        # Write results for each folder
        for folder, functions in folder_functions.items():
            if folder == '.':
                folder = os.path.basename(os.path.abspath(args.input_path))
            output_path = os.path.join(args.output, f"{folder}.csv")
            write_results_to_csv(functions, output_path)
            
    else:
        # Process single file
        functions = process_file(
            args.input_path,
            error_callback=log_error,
            globals_only=args.globals_only
        )
        output_path = os.path.join(
            args.output,
            f"{os.path.splitext(os.path.basename(args.input_path))[0]}.csv"
        )
        write_results_to_csv(functions, output_path)

if __name__ == "__main__":
    main()
