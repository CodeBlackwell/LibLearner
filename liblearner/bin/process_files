#!/usr/bin/env python3

import argparse
import os
import sys
from collections import defaultdict
from liblearner.file_processor import registry, DEFAULT_IGNORE_DIRS
from liblearner.processors import PythonProcessor

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Process files of different types and extract information."
    )
    parser.add_argument(
        "input_path",
        help="Path to file or directory to process"
    )
    parser.add_argument(
        "-o", "--output",
        help="Output directory for results (default: ./output)",
        default="output"
    )
    parser.add_argument(
        "--ignore-dirs",
        nargs="*",
        help=f"Additional directories to ignore (default ignored: {', '.join(sorted(DEFAULT_IGNORE_DIRS))})",
        default=[]
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Show detailed processing information"
    )
    return parser.parse_args()

def log_error(file_path, error_message):
    """Log errors to stderr."""
    print(f"Error processing {file_path}: {error_message}", file=sys.stderr)

def show_progress(file_path, file_type=None):
    """Display progress information."""
    type_info = f" ({file_type})" if file_type else ""
    print(f"Processing {file_path}{type_info}")

def get_file_extension(file_path):
    """Get the file extension from a path."""
    return os.path.splitext(file_path)[1][1:] or "no_extension"

def get_output_filename(base_name, file_path):
    """Generate output filename with extension indication."""
    extension = get_file_extension(file_path)
    return f"{base_name}.{extension}.csv"

def main():
    args = parse_arguments()
    
    # Create output directory if it doesn't exist
    os.makedirs(args.output, exist_ok=True)
    
    # Register available processors
    registry.register_processor(PythonProcessor)
    
    # Dictionary to store results by file type
    results_by_type = defaultdict(lambda: defaultdict(list))
    
    # Process input path
    if os.path.isdir(args.input_path):
        if args.verbose:
            print(f"Processing directory: {args.input_path}")
            
        results = registry.process_directory(args.input_path, args.ignore_dirs)
        
        # Write results for each folder
        for folder, folder_results in results.items():
            if folder == '.':
                folder = os.path.basename(os.path.abspath(args.input_path))
            
            if args.verbose:
                print(f"\nProcessed folder '{folder}':")
                for result in folder_results:
                    show_progress(result['path'], result.get('type'))
                    if 'error' in result:
                        log_error(result['path'], result['error'])
            
            # Group results by extension within the folder
            folder_results_by_ext = defaultdict(list)
            for result in folder_results:
                if result.get('type') and 'functions' in result:
                    extension = get_file_extension(result['path'])
                    folder_results_by_ext[extension].extend(result['functions'])
                    
                    # Also store in global results by type and extension
                    results_by_type[result['type']][extension].extend(result['functions'])
            
            # Write results for each extension in the folder
            for ext, ext_results in folder_results_by_ext.items():
                if ext_results:
                    output_path = os.path.join(args.output, get_output_filename(folder, f"dummy.{ext}"))
                    from liblearner.python_extractor import write_results_to_csv
                    write_results_to_csv(ext_results, output_path)
                    
                    if args.verbose:
                        print(f"Results written to: {output_path}")
    
    else:
        if args.verbose:
            print(f"Processing file: {args.input_path}")
        
        # Process single file
        result = registry.process_file(args.input_path)
        
        if result:
            if args.verbose:
                show_progress(result['path'], result.get('type'))
                if 'error' in result:
                    log_error(result['path'], result['error'])
            
            # Write results to CSV if functions were extracted
            if result.get('type') and 'functions' in result:
                extension = get_file_extension(result['path'])
                results_by_type[result['type']][extension].extend(result['functions'])
                
                base_name = os.path.splitext(os.path.basename(args.input_path))[0]
                output_path = os.path.join(args.output, get_output_filename(base_name, result['path']))
                
                from liblearner.python_extractor import write_results_to_csv
                write_results_to_csv(result['functions'], output_path)
                
                if args.verbose:
                    print(f"Results written to: {output_path}")
        else:
            print(f"No processor available for file: {args.input_path}")
    
    # Write combined results for each file type and extension
    for file_type, extensions_dict in results_by_type.items():
        for ext, type_results in extensions_dict.items():
            if type_results:
                combined_output = os.path.join(args.output, f"all_{file_type}_{ext}.csv")
                from liblearner.python_extractor import write_results_to_csv
                write_results_to_csv(type_results, combined_output)
                
                if args.verbose:
                    print(f"\nCombined {file_type} results for .{ext} files written to: {combined_output}")

if __name__ == "__main__":
    main()
