#!/usr/bin/env python3

import argparse
import os
import sys
from collections import defaultdict
from liblearner.file_processor import registry, DEFAULT_IGNORE_DIRS
from liblearner.processors import (
    PythonProcessor,
    JupyterProcessor,
    YAMLProcessor,
    MarkdownProcessor
)

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Process files of different types and extract information."
    )
    parser.add_argument(
        "input_path",
        help="Path to file or directory to process"
    )
    parser.add_argument(
        "-o", "--output",
        help="Output directory for results (default: ./output)",
        default="output"
    )
    parser.add_argument(
        "--ignore-dirs",
        nargs="*",
        help=f"Additional directories to ignore (default ignored: {', '.join(sorted(DEFAULT_IGNORE_DIRS))})",
        default=[]
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Show detailed processing information"
    )
    return parser.parse_args()

def log_error(file_path, error_message):
    """Log errors to stderr."""
    print(f"Error processing {file_path}: {error_message}", file=sys.stderr)

def show_progress(file_path, file_type=None):
    """Display progress information."""
    type_info = f" ({file_type})" if file_type else ""
    print(f"Processing {file_path}{type_info}")

def get_file_extension(file_path):
    """Get the file extension from a path."""
    return os.path.splitext(file_path)[1][1:] or "no_extension"

def get_output_filename(base_name, file_path):
    """Generate output filename with extension indication."""
    extension = get_file_extension(file_path)
    return f"{base_name}.{extension}.csv"

def main():
    args = parse_arguments()
    
    # Create output directory if it doesn't exist
    os.makedirs(args.output, exist_ok=True)
    
    # Register available processors and set verbose mode
    registry.set_verbose(args.verbose)
    registry.register_processor(PythonProcessor)
    registry.register_processor(JupyterProcessor)
    registry.register_processor(YAMLProcessor)
    registry.register_processor(MarkdownProcessor)
    
    # Process input path
    if os.path.isdir(args.input_path):
        if args.verbose:
            print(f"Processing directory: {args.input_path}")
            
        results = registry.process_directory(args.input_path, args.ignore_dirs)
        
        # Process results
        for folder, folder_results in results.items():
            if folder == '.':
                folder = os.path.basename(os.path.abspath(args.input_path))
            
            if args.verbose:
                print(f"\nProcessed folder '{folder}':")
                for result in folder_results:
                    if isinstance(result, dict):
                        show_progress(result['path'], result.get('type'))
                        if 'error' in result:
                            log_error(result['path'], result['error'])
                    elif isinstance(result, str):
                        print(f"Results written to: {result}")
            
            # Group function-based results by extension
            function_results = defaultdict(list)
            for result in folder_results:
                if isinstance(result, dict) and result.get('type') and 'functions' in result:
                    extension = get_file_extension(result['path'])
                    function_results[extension].extend(result['functions'])
            
            # Write function-based results
            for ext, ext_results in function_results.items():
                if ext_results:
                    output_path = os.path.join(args.output, get_output_filename(folder, f"dummy.{ext}"))
                    from liblearner.python_extractor import write_results_to_csv
                    write_results_to_csv(ext_results, output_path)
                    
                    if args.verbose:
                        print(f"Function results written to: {output_path}")
    
    else:
        if args.verbose:
            print(f"Processing file: {args.input_path}")
        
        # Process single file
        result = registry.process_file(args.input_path)
        
        if result:
            if isinstance(result, dict):
                if args.verbose:
                    show_progress(result['path'], result.get('type'))
                    if 'error' in result:
                        log_error(result['path'], result['error'])
                
                # Write function-based results
                if result.get('type') and 'functions' in result:
                    base_name = os.path.splitext(os.path.basename(args.input_path))[0]
                    output_path = os.path.join(args.output, get_output_filename(base_name, result['path']))
                    
                    from liblearner.python_extractor import write_results_to_csv
                    write_results_to_csv(result['functions'], output_path)
                    
                    if args.verbose:
                        print(f"Function results written to: {output_path}")
            
            elif isinstance(result, str):
                if args.verbose:
                    print(f"Results written to: {result}")
        else:
            print(f"No processor available for file: {args.input_path}")

if __name__ == "__main__":
    main()
